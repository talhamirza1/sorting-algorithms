# This program will use Tk GUI toolkit
# there are 4 sorting algorithms implemented in this program
# 1. Heap Sort
# 2. Count Sort
# 3. Insertion Sort
# 4. Quick Sort
# this program will show the time complexity of these algortithms and
# display how much time does it take to sort the randomly generated array
# I have used websites like geeksforgeeks and programmiz and other websites for help
# This is my first attempt using tkinter GUI and My first Python Project
from tkinter import *
import numpy as np
from random import randint
from timeit import default_timer as timer

# Form
master = Tk()


master.title("My App!")
master.geometry("1800x1800")
# master.iconbitmap('D:/Tkinter-Sorting-Algorithms/download.ico')
master.configure(bg='#1E1E1E')

# Arrays that are to be used by algorithm
# these arrays will given the random array generated by clicked Function
# then these arrays will be separately used by Sorting algorithms and sorted in order of calling
array_for_insert = None
array_for_count = None
array_for_Quick_sort = None
array_for_Heap_sort = None



def clicked():
    global array_for_Quick_sort
    global array_for_insert
    global array_for_count
    global array_for_Heap_sort

    size_of_array = e1.get()
    min_element_of_array = e2.get()
    max_element_of_array = e3.get()

    randnums = np.random.randint(int(min_element_of_array), int(
        max_element_of_array), int(size_of_array))
    array_for_count = array_for_insert = array_for_Heap_sort = array_for_Quick_sort = randnums
    r_List = Label(master, text=randnums, font=('Franklin', 15),
                   width=50).grid(row=15, column=1, sticky=S)


def show_button_to_forget(ll1, ll2, ll3, ee1, ee2, ee3, my_button1):
    global array_for_Quick_sort
    
    smallest = 0
    largest = len(array_for_Quick_sort)-1

    ll1.grid_forget()

    ll2.grid_forget()

    ll3.grid_forget()

    ee1.grid_forget()

    ee2.grid_forget()

    ee3.grid_forget()

    my_button1.grid_forget()

    Algos = Label(master, text="Algorithm", fg='White',
                  bg='#CCDDEA', font=('Franklin', 25))

    Time = Label(master, text="Time", fg='White',
                 bg='#CCDDEA', font=('Franklin', 25))

    Count = Button(master, text="Count Sort!", bg='#FDA023', height=2, font=("Franklin", 12),
                   fg='white', width=20, command=CountSort)

    Quick_sort = Button(master, text="Quick Sort!", bg='#FDA023', height=2, font=("Franklin", 12),
                        fg='white', width=20, command=lambda: QuickSort(array_for_Quick_sort, smallest, largest))

    Insertion_sort = Button(master, text="Insertion Sort!", bg='#FDA023', height=2, font=("Franklin", 12),
                            fg='white', width=20, command=InsertSort)

    Heap_sort = Button(master, text="Heap Sort!", bg='#FDA023', height=2, font=("Franklin", 12),
                       fg='white', width=20, command=heapSort)

    Count1 = Button(master, text="Show Count Sort!", bg='#FDA023', height=2, font=("Franklin", 12),
                    fg='white', width=20, command=show_fun_for_count)

    Quick_sort1 = Button(master, text="Show Quick Sort!", bg='#FDA023', height=2, font=("Franklin", 12),
                         fg='white', width=20, command=show_fun_for_quick)

    Insertion_sort1 = Button(master, text="Insertion Sort!", bg='#FDA023', height=2, font=("Franklin", 12),
                             fg='white', width=20, command=show_fun_for_insert)

    Heap_sort1 = Button(master, text="Show Heap Sort!", bg='#FDA023', height=2, font=("Franklin", 12),
                        fg='white', width=20, command=show_fun_for_heap)

    go_back = Button(master, text="Go Back to generate array!", bg='#FDA023', font=("Franklin", 12), height=2,
                     fg='white', width=40, command=lambda: retrieve(l1, l2, l3, e1, e2, e3, my_button, Algos, Time, Count, Quick_sort, Insertion_sort, Heap_sort, Count1, Quick_sort1, Insertion_sort1, Heap_sort1, go_back))

    Algos.grid(row=1, column=0, pady=20)
    Time.grid(row=1, column=1, pady=20)
    Count.grid(row=2, column=0)
    Quick_sort.grid(row=4, column=0)
    Insertion_sort.grid(row=6, column=0)
    Heap_sort.grid(row=8, column=0)
    Count1.grid(row=2, column=2)
    Quick_sort1.grid(row=4, column=2)
    Insertion_sort1.grid(row=6, column=2)
    Heap_sort1.grid(row=8, column=2)
    go_back.grid(row=12, column=1, pady=20)
    # clear_button.grid(row=12, column=0, pady=20)


def CountSort():
    global array_for_count
    start_time = timer()
    mx = max(array_for_count)
    nl = [0 for i in range(mx+1)]
    rl = []
    for i in array_for_count:
        nl[i] += 1
    for i in range(len(nl)):
        if nl != 0:
            rl += [i for n in range(nl[i])]
    array_for_count = rl
    end_time = timer()
    new_ar = end_time - start_time
    arr_for = Label(master, text=new_ar,
                    width=40).grid(row=2, column=1)


def InsertSort():
    start = timer()
    global array_for_insert
    for i in range(1, len(array_for_insert)):
        key = array_for_insert[i]
        j = i-1
        while j >= 0 and key < array_for_insert[j]:
            array_for_insert[j+1] = array_for_insert[j]
            j -= 1
        array_for_insert[j+1] = key
    end = timer()
    new_var = end - start
    arr_for_insert = Label(master, text=new_var,
                           width=40).grid(row=6, column=1)


def partition_algo(array_var_part, sml, lrg):
    x = array_var_part[lrg]
    i = sml-1
    for j in range(sml, lrg):
        if array_var_part[j] <= x:
            i += 1
            # exchange
            array_var_part[i], array_var_part[j] = array_var_part[j], array_var_part[i]

    array_var_part[i+1], array_var_part[lrg] = array_var_part[lrg], array_var_part[i+1]
    return i+1


def QuickSort(array_quick, sm, lr):
    start = timer()
    if sm < lr:
        piv = partition_algo(array_quick, sm, lr)
        QuickSort(array_quick, sm, piv-1)
        QuickSort(array_quick, piv+1, lr)

    end = timer()
    total = end - start
    quick_sort = Label(master, text=total,
                       width=40).grid(row=4, column=1)


def heap_algo(hs_array, sizes, high_value):
    largest = high_value
    l = 2*high_value+1
    r = 2*high_value+2
    if l < sizes and hs_array[largest] < hs_array[l]:
        largest = l
    if r < sizes and hs_array[largest] < hs_array[r]:
        largest = r
    if largest != high_value:
        hs_array[high_value], hs_array[largest] = hs_array[largest], hs_array[high_value]

        heap_algo(hs_array, sizes, largest)


def heapSort():
    global array_for_Heap_sort
    n = len(array_for_Heap_sort)
    start = timer()
    for i in range(n//2-1, -1, -1):
        heap_algo(array_for_Heap_sort, n, i)

    for i in range(n-1, 0, -1):
        array_for_Heap_sort[i], array_for_Heap_sort[0] = array_for_Heap_sort[0], array_for_Heap_sort[i]
        heap_algo(array_for_Heap_sort, i, 0)

    end = timer()
    new_var = end - start
    arr_for_heap = Label(master, text=new_var,
                         width=40).grid(row=8, column=1)


# this function will Display the Sorted array on Grid


def show_fun_for_count():
    global array_for_count
    arr_insert = Label(master, text="This is Count "+str(array_for_count), width=60,
                       height=3).grid(row=2, column=4)


def show_fun_for_insert():
    global array_for_insert
    arr_count = Label(master, text="This is Insert "+str(array_for_insert), width=60,
                      height=3).grid(row=6, column=4)


def show_fun_for_heap():
    global array_for_Heap_sort
    arr_heap = Label(master, text="This is Heap "+str(array_for_Heap_sort), width=60,
                     height=3).grid(row=8, column=4)


def show_fun_for_quick():
    global array_for_Quick_sort
    arr_quick = Label(master, text="This is Quick "+str(array_for_Quick_sort), width=60,
                      height=3).grid(row=4, column=4)


# Function to bring previous data on screen

def retrieve(ll1, ll2, ll3, ee1, ee2, ee3, my_button1, a, t, b, q, i, h, b1, q1, i1, h1, gb):
    ll1.grid(row=2, column=0, sticky=W, pady=20, padx=20)
    #
    ll2.grid(row=4, column=0, sticky=W, pady=20, padx=20)
    #
    ll3.grid(row=6, column=0, sticky=W, pady=20, padx=20)
    #
    ee1.grid(row=2, column=1, pady=20)
    #
    ee2.grid(row=4, column=1, pady=20)
    #
    ee3.grid(row=6, column=1, pady=20)
    #
    my_button1.grid(row=10, column=1, pady=20)
    #
    gb.grid_forget()
    a.grid_forget()
    t.grid_forget()
    b.grid_forget()
    q.grid_forget()
    i.grid_forget()
    h.grid_forget()
    b1.grid_forget()
    q1.grid_forget()
    i1.grid_forget()
    h1.grid_forget()
    #


# Title label
mylable = Label(master, text="Sorting Algorithms", fg='White',
                bg='#CCDDEA', font=('Algerian', 25))

# this wil create a label widget against entry widget
l1 = Label(master, text="Size of Array", fg='White', width=15,
           bg='#F89E27', font=('Franklin ', 15))

l2 = Label(master, text="Minimum Element", fg='White', width=15,
           bg='#F89E27', font=('Franklin ', 15))

l3 = Label(master, text="Maximum Element", fg='White', width=15,
           bg='#F89E27', font=('Franklin ', 15))


# entry widgets, used to take entry from user
e1 = Entry(master, width=30, font=('Franklin', 15))
e2 = Entry(master, width=30, font=('Franklin', 15))
e3 = Entry(master, width=30, font=('Franklin', 15))


# Button to generate array of random numbers
my_button = Button(master, text="Generate Array", bg='#FDA023', height=2, font=("Franklin", 12),
                   fg='white', width=40, command=lambda: clicked())

# Button to start sorting array of random numbers
Show_Array = Button(master, text="Sort Now!", bg='#FDA023', font=("Franklin", 12), height=2,
                    fg='white', width=40, command=lambda: show_button_to_forget(l1, l2, l3, e1, e2, e3, my_button))


# Title text will be displayd by this
mylable.grid(row=0, column=1, sticky=W, pady=20)

# this will arrange Label of entry widgets on Form
l1.grid(row=2, column=0, sticky=W, pady=20, padx=20)
l2.grid(row=4, column=0, sticky=W, pady=20, padx=20)
l3.grid(row=6, column=0, sticky=W, pady=20, padx=20)

# this will arrange entry widgets on Form
e1.grid(row=2, column=1, pady=20)
e2.grid(row=4, column=1, pady=20)
e3.grid(row=6, column=1, pady=20)

# this will arrange Buttons widgets on Form of main Screen
my_button.grid(row=10, column=1, pady=20)
Show_Array.grid(row=12, column=1, pady=20)

mainloop()
